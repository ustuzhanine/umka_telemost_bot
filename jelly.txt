// üçØ –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Ñ–∏–∑–∏–∫–∞ –º–∞—Ä–º–µ–ª–∞–¥–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
// –û—Å–Ω–æ–≤–∞–Ω–∞ –Ω–∞ –≤—è–∑–∫–æ—É–ø—Ä—É–≥–æ–π –º–æ–¥–µ–ª–∏ —Å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π —Ç–æ—á–µ—á–Ω—ã—Ö –º–∞—Å—Å

class JellyPhysics {
    constructor() {
        this.objects = [];
        this.gravity = 0.4;                 // –£–º–µ–Ω—å—à–µ–Ω–∞ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –¥–ª—è –º—è–≥–∫–æ–≥–æ –ø–∞–¥–µ–Ω–∏—è
        
        // –í–Ø–ó–ö–û–£–ü–†–£–ì–ò–ï –ü–ê–†–ê–ú–ï–¢–†–´ (–∫–ª—é—á –∫ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–º—É –∂–µ–ª–µ)
        this.viscosity = 0.15;              // –í—è–∑–∫–æ—Å—Ç—å - —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏ (0..1)
        this.elasticity = 0.8;              // –£–ø—Ä—É–≥–æ—Å—Ç—å - —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è –≤ —Ñ–æ—Ä–º—É (0..1)
        this.relaxationTime = 60;           // –í—Ä–µ–º—è —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏ (–∫–∞–¥—Ä—ã) - –∫–∞–∫ –±—ã—Å—Ç—Ä–æ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è —Ñ–æ—Ä–º–∞
        this.dampingRatio = 0.3;            // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞—Ç—É—Ö–∞–Ω–∏—è –¥–ª—è oscillations
        
        // –î–ï–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´
        this.maxDeformation = 0.6;          // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è (0.4 = 60% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞)
        this.deformationStiffness = 0.08;   // –ñ–µ—Å—Ç–∫–æ—Å—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–æ—Ä–º—ã
        this.shearModulus = 0.12;           // –ú–æ–¥—É–ª—å —Å–¥–≤–∏–≥–∞ –¥–ª—è –±–æ–∫–æ–≤—ã—Ö –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–π
        this.compressionModulus = 0.2;      // –ú–æ–¥—É–ª—å —Å–∂–∞—Ç–∏—è –¥–ª—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–π
        
        // –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø
        this.surfaceTension = 0.95;         // –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ–µ –Ω–∞—Ç—è–∂–µ–Ω–∏–µ (—Å—Ç—Ä–µ–º–ª–µ–Ω–∏–µ –∫ –∫—Ä—É–≥–ª–æ–π —Ñ–æ—Ä–º–µ)
        this.cohesion = 0.7;                // –°–ª–∏–ø–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º
        this.groundFriction = 0.8;          // –¢—Ä–µ–Ω–∏–µ —Å –∑–µ–º–ª–µ–π
        this.groundY = window.innerHeight;
        this.wallBounciness = 0.1;          // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω
        
        // –°–ò–°–¢–ï–ú–ê –í–ù–£–¢–†–ï–ù–ù–ò–• –¢–û–ß–ï–ö (–¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏)
        this.internalPointsPerObject = 5;   // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –º–∞—Å—Å –Ω–∞ –æ–±—ä–µ–∫—Ç
        this.springConstant = 0.15;         // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –ø—Ä—É–∂–∏–Ω –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏
        this.internalDamping = 0.85;        // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∫–æ–ª–µ–±–∞–Ω–∏–π
        
        this.animationId = null;
        this.init();
    }

    init() {
        const container = document.querySelector('.floating-shapes');
        if (!container) {
            console.log(`–î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –∂–µ–ª–µ–π–Ω—ã–π –æ–±—ä–µ–∫—Ç. –í—Å–µ–≥–æ: ${this.objects.length}`);
    }
    
    // –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –ù–ê–°–¢–†–û–ô–ö–ò –ñ–ï–õ–ï–ô–ù–´–• –°–í–û–ô–°–¢–í
    
    // –î–µ–ª–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã –±–æ–ª–µ–µ –≤—è–∑–∫–∏–º–∏ (–º–µ–¥–ª–µ–Ω–Ω–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ, –±–æ–ª—å—à–µ —Å–ª–∏–ø–∞–Ω–∏–µ)
    increaseViscosity(amount = 0.1) {
        this.viscosity = Math.min(0.9, this.viscosity + amount);
        console.log(`–í—è–∑–∫–æ—Å—Ç—å —É–≤–µ–ª–∏—á–µ–Ω–∞ –¥–æ ${this.viscosity.toFixed(2)}`);
    }
    
    // –î–µ–ª–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã –±–æ–ª–µ–µ —É–ø—Ä—É–≥–∏–º–∏ (–±—ã—Å—Ç—Ä–µ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ä–º—ã)
    increaseElasticity(amount = 0.1) {
        this.elasticity = Math.min(1, this.elasticity + amount);
        console.log(`–£–ø—Ä—É–≥–æ—Å—Ç—å —É–≤–µ–ª–∏—á–µ–Ω–∞ –¥–æ ${this.elasticity.toFixed(2)}`);
    }
    
    // –ò–∑–º–µ–Ω—è–µ—Ç –≤—Ä–µ–º—è —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏ (–∫–∞–∫ –±—ã—Å—Ç—Ä–æ –∂–µ–ª–µ —É—Å–ø–æ–∫–∞–∏–≤–∞–µ—Ç—Å—è)
    setRelaxationTime(frames) {
        this.relaxationTime = Math.max(10, Math.min(200, frames));
        console.log(`–í—Ä–µ–º—è —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: ${this.relaxationTime} –∫–∞–¥—Ä–æ–≤`);
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏–ª—ã –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
    setDeformationIntensity(factor) {
        this.maxDeformation = Math.max(0.1, Math.min(0.8, factor));
        this.deformationStiffness = this.maxDeformation * 0.15;
        console.log(`–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏: ${this.maxDeformation.toFixed(2)}`);
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–ª–∏–ø–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
    setCohesion(amount) {
        this.cohesion = Math.max(0, Math.min(1, amount));
        console.log(`–°–ª–∏–ø–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: ${this.cohesion.toFixed(2)}`);
    }
    
    // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    getStats() {
        const activeObjects = this.objects.filter(obj => obj.energy > 0.5).length;
        const avgEnergy = this.objects.reduce((sum, obj) => sum + obj.energy, 0) / this.objects.length;
        const maxDeformation = Math.max(...this.objects.map(obj => 
            Math.abs(obj.strain.x) + Math.abs(obj.strain.y)
        ));
        
        return {
            totalObjects: this.objects.length,
            activeObjects: activeObjects,
            averageEnergy: avgEnergy.toFixed(2),
            maxDeformation: maxDeformation.toFixed(2),
            viscosity: this.viscosity,
            elasticity: this.elasticity
        };
    }
    
    // –°–æ–∑–¥–∞—Ç—å –∂–µ–ª–µ–π–Ω—ã–π –≤–∑—Ä—ã–≤ –≤ —Ç–æ—á–∫–µ (–¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏)
    createJellyExplosion(x, y, force = 5) {
        this.objects.forEach(obj => {
            const dx = obj.x - x;
            const dy = obj.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxRadius = 150;
            
            if (distance < maxRadius) {
                const proximity = 1 - (distance / maxRadius);
                const explosionForce = force * proximity;
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–¥–∏–∞–ª—å–Ω—É—é —Å–∏–ª—É
                if (distance > 0) {
                    obj.vx += (dx / distance) * explosionForce;
                    obj.vy += (dy / distance) * explosionForce;
                }
                
                // –°–∏–ª—å–Ω–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç –≤–∑—Ä—ã–≤–∞
                obj.strain.x += (Math.random() - 0.5) * explosionForce * 0.1;
                obj.strain.y += (Math.random() - 0.5) * explosionForce * 0.1;
                obj.strainRate.x = explosionForce * 0.2;
                obj.strainRate.y = explosionForce * 0.2;
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –æ—Ç –≤–∑—Ä—ã–≤–∞
                obj.angularVelocity += (Math.random() - 0.5) * explosionForce * 0.05;
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω—É—é —Ä–µ–ª–∞–∫—Å–∞—Ü–∏—é
                obj.relaxationCounter = this.relaxationTime * 2;
                obj.energy += explosionForce;
                obj.lastCollisionTime = Date.now();
            }
        });
    }
}

// –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï:
// const jellyPhysics = new JellyPhysics();
// 
// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:
// jellyPhysics.increaseViscosity(0.2);     // –ë–æ–ª–µ–µ –≤—è–∑–∫–æ–µ –∂–µ–ª–µ
// jellyPhysics.setDeformationIntensity(0.5); // –ë–æ–ª—å—à–µ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–π
// jellyPhysics.setCohesion(0.8);           // –û–±—ä–µ–∫—Ç—ã —Å–∏–ª—å–Ω–µ–µ —Å–ª–∏–ø–∞—é—Ç—Å—è
//
// –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:
// document.addEventListener('click', (e) => {
//     jellyPhysics.createJellyExplosion(e.clientX, e.clientY, 8);
// });
//
// –û—Ç–ª–∞–¥–∫–∞:
// setInterval(() => console.log(jellyPhysics.getStats()), 5000);error('–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä .floating-shapes –Ω–µ –Ω–∞–π–¥–µ–Ω!');
            return;
        }

        const elements = container.querySelectorAll('.snowflake');
        console.log(`–°–æ–∑–¥–∞–µ–º –∂–µ–ª–µ–π–Ω—É—é —Ñ–∏–∑–∏–∫—É –¥–ª—è ${elements.length} –æ–±—ä–µ–∫—Ç–æ–≤`);

        elements.forEach((element, index) => {
            const width = this.getElementWidth(element);
            const height = this.getElementHeight(element);

            const obj = {
                element: element,
                
                // –û–°–ù–û–í–ù–´–ï –§–ò–ó–ò–ß–ï–°–ö–ò–ï –°–í–û–ô–°–¢–í–ê
                x: Math.random() * (window.innerWidth - width),
                y: -100 - Math.random() * 300,
                vx: (Math.random() - 0.5) * 1,
                vy: Math.random() * 1 + 0.5,
                width: width,
                height: height,
                mass: this.getElementMass(element),
                
                // –í–Ø–ó–ö–û–£–ü–†–£–ì–ò–ï –°–í–û–ô–°–¢–í–ê
                strain: { x: 0, y: 0 },             // –¢–µ–∫—É—â–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è
                strainRate: { x: 0, y: 0 },         // –°–∫–æ—Ä–æ—Å—Ç—å –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
                stress: { x: 0, y: 0 },             // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ
                relaxationCounter: 0,               // –°—á–µ—Ç—á–∏–∫ –≤—Ä–µ–º–µ–Ω–∏ —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏
                
                // –§–û–†–ú–ê –ò –î–ï–§–û–†–ú–ê–¶–ò–Ø
                scaleX: 1,                          // –ú–∞—Å—à—Ç–∞–± –ø–æ X (—Å–∂–∞—Ç–∏–µ/—Ä–∞—Å—Ç—è–∂–µ–Ω–∏–µ)
                scaleY: 1,                          // –ú–∞—Å—à—Ç–∞–± –ø–æ Y
                shear: 0,                           // –°–¥–≤–∏–≥ (–Ω–∞–∫–ª–æ–Ω)
                rotation: 0,
                angularVelocity: 0,
                
                // –í–ù–£–¢–†–ï–ù–ù–Ø–Ø –°–¢–†–£–ö–¢–£–†–ê (—Ç–æ—á–µ—á–Ω—ã–µ –º–∞—Å—Å—ã)
                internalPoints: [],                 // –ú–∞—Å—Å—ã –≤–Ω—É—Ç—Ä–∏ –æ–±—ä–µ–∫—Ç–∞
                restShape: { width: width, height: height }, // –§–æ—Ä–º–∞ –ø–æ–∫–æ—è
                
                // –°–û–°–¢–û–Ø–ù–ò–ï
                onGround: false,
                energy: 0,                          // –ö–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                lastCollisionTime: 0,
                isActive: true                      // –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞
            };

            // –°–æ–∑–¥–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–æ—á–µ—á–Ω—ã—Ö –º–∞—Å—Å
            this.createInternalStructure(obj);
            
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º DOM —ç–ª–µ–º–µ–Ω—Ç
            this.setupElement(obj);
            
            this.objects.push(obj);
        });

        this.startAnimation();
    }
    
    // –°–æ–∑–¥–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å–µ—Ç—å —Ç–æ—á–µ—á–Ω—ã—Ö –º–∞—Å—Å –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
    createInternalStructure(obj) {
        const points = [];
        const gridSize = Math.ceil(Math.sqrt(this.internalPointsPerObject));
        
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (points.length >= this.internalPointsPerObject) break;
                
                points.push({
                    localX: (i / (gridSize - 1)) || 0.5,  // –ü–æ–∑–∏—Ü–∏—è 0..1
                    localY: (j / (gridSize - 1)) || 0.5,
                    vx: 0,
                    vy: 0,
                    mass: obj.mass / this.internalPointsPerObject
                });
            }
        }
        
        obj.internalPoints = points;
    }

    setupElement(element) {
        element.style.animation = 'none';
        element.style.position = 'absolute';
        element.style.transition = 'none';
        element.style.transformOrigin = '50% 50%';
        element.style.opacity = '0.8';
        element.style.zIndex = '1';
    }

    getElementWidth(element) {
        const svg = element.querySelector('svg');
        return (svg ? parseInt(svg.getAttribute('width')) || 50 : 50) * 1.2;
    }

    getElementHeight(element) {
        const svg = element.querySelector('svg');
        return (svg ? parseInt(svg.getAttribute('height')) || 50 : 50) * 1.2;
    }

    getElementMass(element) {
        const width = this.getElementWidth(element);
        return Math.max(0.5, width / 80); // –ú–µ–Ω—å—à–µ –º–∞—Å—Å–∞ = –±–æ–ª–µ–µ –∂–µ–ª–µ–π–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
    }

    update() {
        this.objects.forEach((obj, index) => {
            this.updateViscosity(obj);
            this.updateElasticity(obj);
            this.updateInternalStructure(obj);
            this.updatePhysicalMovement(obj);
            this.checkCollisions(obj, index);
            this.updateDeformation(obj);
            this.updateElement(obj);
        });
    }
    
    // –í–Ø–ó–ö–û–°–¢–¨: —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ñ–æ—Ä–º—ã
    updateViscosity(obj) {
        // –í—è–∑–∫–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        const strainMagnitude = Math.sqrt(obj.strainRate.x * obj.strainRate.x + obj.strainRate.y * obj.strainRate.y);
        const viscousForce = this.viscosity * strainMagnitude;
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—è–∑–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
        obj.vx *= (1 - viscousForce * 0.1);
        obj.vy *= (1 - viscousForce * 0.1);
        obj.angularVelocity *= (1 - viscousForce * 0.2);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        obj.strainRate.x *= 0.9;
        obj.strainRate.y *= 0.9;
    }
    
    // –£–ü–†–£–ì–û–°–¢–¨: –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∫ –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–µ
    updateElasticity(obj) {
        // –£–ø—Ä—É–≥–∞—è —Å–∏–ª–∞ —Å—Ç—Ä–µ–º–∏—Ç—Å—è –≤–µ—Ä–Ω—É—Ç—å –æ–±—ä–µ–∫—Ç –∫ –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–µ
        const elasticForceX = -obj.strain.x * this.elasticity * this.deformationStiffness;
        const elasticForceY = -obj.strain.y * this.elasticity * this.deformationStiffness;
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ø—Ä—É–≥–∏–µ —Å–∏–ª—ã –∫ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        obj.strain.x += elasticForceX;
        obj.strain.y += elasticForceY;
        
        // –†–µ–ª–∞–∫—Å–∞—Ü–∏—è - –º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∫ –ø–æ–∫–æ—é
        if (obj.relaxationCounter > 0) {
            obj.relaxationCounter--;
            const relaxationFactor = 1 - (obj.relaxationCounter / this.relaxationTime);
            obj.strain.x *= (1 - relaxationFactor * 0.02);
            obj.strain.y *= (1 - relaxationFactor * 0.02);
        }
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—é
        obj.strain.x = Math.max(-this.maxDeformation, Math.min(this.maxDeformation, obj.strain.x));
        obj.strain.y = Math.max(-this.maxDeformation, Math.min(this.maxDeformation, obj.strain.y));
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–æ—á–µ—á–Ω—ã—Ö –º–∞—Å—Å
    updateInternalStructure(obj) {
        obj.internalPoints.forEach((point, i) => {
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –≤–ª–∏—è–µ—Ç –Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ç–æ—á–∫–∏
            point.vy += this.gravity * 0.3;
            
            // –ü—Ä—É–∂–∏–Ω–Ω—ã–µ —Å–∏–ª—ã –∫ —Å–æ—Å–µ–¥–Ω–∏–º —Ç–æ—á–∫–∞–º
            obj.internalPoints.forEach((other, j) => {
                if (i === j) return;
                
                const dx = (other.localX - point.localX) * obj.width;
                const dy = (other.localY - point.localY) * obj.height;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < obj.width * 0.7) { // –¢–æ–ª—å–∫–æ –±–ª–∏–∑–∫–∏–µ —Ç–æ—á–∫–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—é—Ç
                    const force = this.springConstant * (distance - obj.width * 0.3);
                    const fx = (dx / distance) * force * 0.1;
                    const fy = (dy / distance) * force * 0.1;
                    
                    point.vx += fx / point.mass;
                    point.vy += fy / point.mass;
                }
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–æ—á–∫–∏
            point.localX += point.vx * 0.01;
            point.localY += point.vy * 0.01;
            
            // –î–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –¥–≤–∏–∂–µ–Ω–∏–π
            point.vx *= this.internalDamping;
            point.vy *= this.internalDamping;
            
            // –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ –æ–±—ä–µ–∫—Ç–∞
            point.localX = Math.max(0.1, Math.min(0.9, point.localX));
            point.localY = Math.max(0.1, Math.min(0.9, point.localY));
        });
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–º–µ—â–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Ç–æ—á–µ–∫
        const avgShiftX = obj.internalPoints.reduce((sum, p) => sum + (p.localX - 0.5), 0) / obj.internalPoints.length;
        const avgShiftY = obj.internalPoints.reduce((sum, p) => sum + (p.localY - 0.5), 0) / obj.internalPoints.length;
        
        obj.strain.x += avgShiftX * 0.1;
        obj.strain.y += avgShiftY * 0.1;
    }

    updatePhysicalMovement(obj) {
        // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è —Å —É—á–µ—Ç–æ–º –≤—è–∑–∫–æ—Å—Ç–∏
        obj.vy += this.gravity * (1 - this.viscosity * 0.3);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
        obj.x += obj.vx;
        obj.y += obj.vy;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ —Å –∑–∞—Ç—É—Ö–∞–Ω–∏–µ–º
        obj.rotation += obj.angularVelocity;
        obj.angularVelocity *= (1 - this.dampingRatio * 0.1);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞
        this.checkBounds(obj);
        this.checkGroundCollision(obj);
        
        // –û–±—â–µ–µ –≤—è–∑–∫–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ (–∏–º–∏—Ç–∏—Ä—É–µ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Ç—Ä–µ–Ω–∏–µ –∂–µ–ª–µ)
        obj.vx *= (1 - this.viscosity * 0.05);
        obj.vy *= (1 - this.viscosity * 0.03);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —ç–Ω–µ—Ä–≥–∏—é –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        obj.energy = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) + Math.abs(obj.angularVelocity) * 5;
    }

    checkCollisions(obj, currentIndex) {
        this.objects.forEach((other, otherIndex) => {
            if (currentIndex === otherIndex) return;

            const dx = obj.x - other.x;
            const dy = obj.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = (obj.width + other.width) * 0.4; // –ë–ª–∏–∂–µ –¥–ª—è –∂–µ–ª–µ–π–Ω–æ–≥–æ –∫–æ–Ω—Ç–∞–∫—Ç–∞

            if (distance < minDistance && distance > 0) {
                this.handleJellyCollision(obj, other, dx, dy, distance, minDistance);
            }
        });
    }
    
    // –ñ–ï–õ–ï–ô–ù–´–ï –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–Ø: –º—è–≥–∫–∏–µ, —Å –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–µ–π, –±–µ–∑ –∂–µ—Å—Ç–∫–∏—Ö –æ—Ç—Å–∫–æ–∫–æ–≤
    handleJellyCollision(obj1, obj2, dx, dy, distance, minDistance) {
        const overlap = minDistance - distance;
        const nx = dx / distance;
        const ny = dy / distance;
        
        // –ú—è–≥–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ (–Ω–µ —Ä–µ–∑–∫–æ–µ –≤—ã—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ)
        const separationStrength = overlap * 0.3; // –ú—è–≥—á–µ —á–µ–º —É —Ç–≤–µ—Ä–¥—ã—Ö —Ç–µ–ª
        obj1.x += nx * separationStrength * 0.5;
        obj1.y += ny * separationStrength * 0.5;
        obj2.x -= nx * separationStrength * 0.5;
        obj2.y -= ny * separationStrength * 0.5;
        
        // –ñ–ï–õ–ï–ô–ù–ê–Ø –î–ï–§–û–†–ú–ê–¶–ò–Ø –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
        const impactForce = Math.sqrt(obj1.vx * obj1.vx + obj1.vy * obj1.vy) + 
                           Math.sqrt(obj2.vx * obj2.vx + obj2.vy * obj2.vy);
        
        // –î–µ—Ñ–æ—Ä–º–∏—Ä—É–µ–º –æ–±–∞ –æ–±—ä–µ–∫—Ç–∞
        const deformationAmount = Math.min(this.maxDeformation, impactForce * 0.1);
        
        // –û–±—ä–µ–∫—Ç 1 –¥–µ—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞
        obj1.strain.x += nx * deformationAmount * 0.3;
        obj1.strain.y += ny * deformationAmount * 0.3;
        obj1.strainRate.x = nx * impactForce * 0.1;
        obj1.strainRate.y = ny * impactForce * 0.1;
        
        // –û–±—ä–µ–∫—Ç 2 –¥–µ—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
        obj2.strain.x -= nx * deformationAmount * 0.3;
        obj2.strain.y -= ny * deformationAmount * 0.3;
        obj2.strainRate.x = -nx * impactForce * 0.1;
        obj2.strainRate.y = -ny * impactForce * 0.1;
        
        // –í–Ø–ó–ö–û–£–ü–†–£–ì–ò–ô –ò–ú–ü–£–õ–¨–° (–Ω–µ —Ä–µ–∑–∫–∏–π –æ—Ç—Å–∫–æ–∫, –∞ –º—è–≥–∫–æ–µ –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ)
        const relativeVx = obj1.vx - obj2.vx;
        const relativeVy = obj1.vy - obj2.vy;
        const relativeVelocityNormal = relativeVx * nx + relativeVy * ny;
        
        if (relativeVelocityNormal < 0) {
            const totalMass = obj1.mass + obj2.mass;
            const impulse = (2 * relativeVelocityNormal) / totalMass;
            
            // –ú—è–≥–∫–æ–µ –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–º–ø—É–ª—å—Å–∞ (—É—á–∏—Ç—ã–≤–∞–µ—Ç –≤—è–∑–∫–æ—Å—Ç—å)
            const impulseScale = (1 - this.viscosity * 0.5) * this.cohesion;
            
            obj1.vx -= impulse * obj2.mass * nx * impulseScale;
            obj1.vy -= impulse * obj2.mass * ny * impulseScale;
            obj2.vx += impulse * obj1.mass * nx * impulseScale;
            obj2.vy += impulse * obj1.mass * ny * impulseScale;
        }
        
        // –ñ–ï–õ–ï–ô–ù–û–ï –°–õ–ò–ü–ê–ù–ò–ï –ø—Ä–∏ –º–µ–¥–ª–µ–Ω–Ω–æ–º –∫–æ–Ω—Ç–∞–∫—Ç–µ
        if (impactForce < 2) {
            const stickiness = this.cohesion * (1 - impactForce * 0.2);
            obj1.vx *= (1 - stickiness * 0.1);
            obj1.vy *= (1 - stickiness * 0.1);
            obj2.vx *= (1 - stickiness * 0.1);
            obj2.vy *= (1 - stickiness * 0.1);
        }
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–µ–ª–∞–∫—Å–∞—Ü–∏—é
        obj1.relaxationCounter = this.relaxationTime;
        obj2.relaxationCounter = this.relaxationTime;
        obj1.lastCollisionTime = Date.now();
        obj2.lastCollisionTime = Date.now();
    }

    checkGroundCollision(obj) {
        if (obj.y + obj.height >= this.groundY) {
            obj.y = this.groundY - obj.height;
            obj.onGround = true;

            // –ñ–ï–õ–ï–ô–ù–´–ô –£–î–ê–† –û –ó–ï–ú–õ–Æ: —Å–∏–ª—å–Ω–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è, –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç—Å–∫–æ–∫
            const impactVelocity = Math.abs(obj.vy);
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ —Å–∂–∞—Ç–∏–µ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Å–∫–æ—Ä–æ—Å—Ç–∏ —É–¥–∞—Ä–∞
            const compressionAmount = Math.min(this.maxDeformation, impactVelocity * 0.15);
            obj.strain.y -= compressionAmount; // –°–∂–∏–º–∞–µ–º –ø–æ Y
            obj.strain.x += compressionAmount * 0.3; // –†–∞—Å—Ç—è–≥–∏–≤–∞–µ–º –ø–æ X (–∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–µ–µ –∂–µ–ª–µ)
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
            obj.strainRate.y = -impactVelocity * 0.2;
            obj.strainRate.x = impactVelocity * 0.1;
            
            // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç—Å–∫–æ–∫ —Å –≤—è–∑–∫–∏–º –∑–∞—Ç—É—Ö–∞–Ω–∏–µ–º
            obj.vy = -obj.vy * this.wallBounciness * (1 - this.viscosity);
            obj.vx *= this.groundFriction; // –¢—Ä–µ–Ω–∏–µ
            
            // –ì–∞—Å–∏–º –≤—Ä–∞—â–µ–Ω–∏–µ –ø—Ä–∏ –∫–æ–Ω—Ç–∞–∫—Ç–µ —Å –∑–µ–º–ª–µ–π
            obj.angularVelocity *= 0.3;
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–µ–ª–∞–∫—Å–∞—Ü–∏—é –ø–æ—Å–ª–µ —É–¥–∞—Ä–∞
            obj.relaxationCounter = this.relaxationTime * 1.5; // –î–æ–ª—å—à–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —É–¥–∞—Ä–∞ –æ –∑–µ–º–ª—é
            obj.lastCollisionTime = Date.now();
        } else {
            obj.onGround = false;
        }
    }

    checkBounds(obj) {
        let hitWall = false;
        
        // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
        if (obj.x < 0) {
            obj.x = 0;
            obj.vx = Math.abs(obj.vx) * this.wallBounciness;
            obj.strain.x -= Math.abs(obj.vx) * 0.1; // –î–µ—Ñ–æ—Ä–º–∞—Ü–∏—è –ø—Ä–∏ —É–¥–∞—Ä–µ –æ —Å—Ç–µ–Ω—É
            hitWall = true;
        }
        
        // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞  
        if (obj.x + obj.width > window.innerWidth) {
            obj.x = window.innerWidth - obj.width;
            obj.vx = -Math.abs(obj.vx) * this.wallBounciness;
            obj.strain.x += Math.abs(obj.vx) * 0.1;
            hitWall = true;
        }
        
        if (hitWall) {
            obj.relaxationCounter = this.relaxationTime;
            obj.angularVelocity *= 0.4;
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—è–∑–∫–æ—É–ø—Ä—É–≥–æ–π –º–æ–¥–µ–ª–∏
    updateDeformation(obj) {
        // –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ–µ –Ω–∞—Ç—è–∂–µ–Ω–∏–µ —Å—Ç—Ä–µ–º–∏—Ç—Å—è –∫ –∫—Ä—É–≥–ª–æ–π —Ñ–æ—Ä–º–µ
        const surfaceForceX = -Math.sign(obj.strain.x) * this.surfaceTension * 0.02;
        const surfaceForceY = -Math.sign(obj.strain.y) * this.surfaceTension * 0.02;
        
        obj.strain.x += surfaceForceX;
        obj.strain.y += surfaceForceY;
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        obj.scaleX = 1 + obj.strain.x;
        obj.scaleY = 1 + obj.strain.y;
        
        // –°–¥–≤–∏–≥ –∫–∞–∫ –≤—Ç–æ—Ä–∏—á–Ω–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è
        if (Math.abs(obj.angularVelocity) > 0.01) {
            obj.shear += obj.angularVelocity * 0.5;
            obj.shear *= 0.95; // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–¥–≤–∏–≥–∞
        }
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Å–¥–≤–∏–≥
        obj.shear = Math.max(-0.3, Math.min(0.3, obj.shear));
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è
    updateInternalStructure(obj) {
        // –í–ª–∏—è–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö —Å–∏–ª –Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ç–æ—á–∫–∏
        obj.internalPoints.forEach(point => {
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–∞—Å—Å—ã
            point.vy += this.gravity * 0.2;
            
            // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –¥–≤–∏–∂–µ–Ω–∏–π
            point.vx *= this.internalDamping;
            point.vy *= this.internalDamping;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
            const maxInternalSpeed = 0.5;
            if (Math.abs(point.vx) > maxInternalSpeed) point.vx = Math.sign(point.vx) * maxInternalSpeed;
            if (Math.abs(point.vy) > maxInternalSpeed) point.vy = Math.sign(point.vy) * maxInternalSpeed;
        });
        
        // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è –æ–±—â–µ–π –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        let avgDeviationX = 0;
        let avgDeviationY = 0;
        
        obj.internalPoints.forEach(point => {
            avgDeviationX += Math.abs(point.localX - 0.5);
            avgDeviationY += Math.abs(point.localY - 0.5);
        });
        
        avgDeviationX /= obj.internalPoints.length;
        avgDeviationY /= obj.internalPoints.length;
        
        // –í–ª–∏—è–µ–º –Ω–∞ –≤–Ω–µ—à–Ω—é—é –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—é —á–µ—Ä–µ–∑ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        obj.strain.x += (avgDeviationX - 0.2) * 0.1;
        obj.strain.y += (avgDeviationY - 0.2) * 0.1;
    }

    updateElement(obj) {
        // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º –≤—Å–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –∂–µ–ª–µ–π–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        const combinedScaleX = obj.scaleX * (1 + Math.sin(Date.now() * 0.01) * obj.energy * 0.01);
        const combinedScaleY = obj.scaleY * (1 + Math.cos(Date.now() * 0.008) * obj.energy * 0.01);
        
        // –ñ–µ–ª–µ–π–Ω—ã–π —Ç—Ä–µ–º–æ—Ä –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π —ç–Ω–µ—Ä–≥–∏–∏
        const tremor = obj.energy > 3 ? Math.sin(Date.now() * 0.1) * obj.energy * 0.2 : 0;
        
        obj.element.style.transform = `
            translate(${obj.x + tremor}px, ${obj.y}px)
            rotate(${obj.rotation + obj.shear * 0.1}rad)
            scale(${combinedScaleX}, ${combinedScaleY})
            skew(${obj.shear * 10}deg, 0deg)
        `;
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã: —Ü–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        const deformationIntensity = Math.abs(obj.strain.x) + Math.abs(obj.strain.y);
        const opacity = Math.max(0.6, 1 - deformationIntensity * 0.5);
        obj.element.style.opacity = opacity;
        
        // –†–∞–∑–º—ã—Ç–∏–µ –ø—Ä–∏ –±—ã—Å—Ç—Ä–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏
        const blur = Math.min(2, obj.energy * 0.1);
        if (blur > 0.1) {
            obj.element.style.filter = `blur(${blur}px)`;
        } else {
            obj.element.style.filter = 'none';
        }
    }

    startAnimation() {
        const animate = () => {
            this.update();
            this.animationId = requestAnimationFrame(animate);
        };
        animate();
    }

    stop() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –∂–µ–ª–µ–π–Ω—ã–π –æ–±—ä–µ–∫—Ç
    addObject() {
        const container = document.querySelector('.floating-shapes');
        const templates = container.querySelectorAll('.snowflake');
        if (templates.length === 0) return;

        const template = templates[Math.floor(Math.random() * templates.length)];
        const newElement = template.cloneNode(true);
        container.appendChild(newElement);

        const width = this.getElementWidth(newElement);
        const height = this.getElementHeight(newElement);

        const obj = {
            element: newElement,
            x: Math.random() * (window.innerWidth - width),
            y: -200 - Math.random() * 100,
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() + 0.5,
            width: width,
            height: height,
            mass: this.getElementMass(newElement),
            
            // –í—è–∑–∫–æ—É–ø—Ä—É–≥–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞
            strain: { x: 0, y: 0 },
            strainRate: { x: 0, y: 0 },
            stress: { x: 0, y: 0 },
            relaxationCounter: 0,
            
            // –§–æ—Ä–º–∞
            scaleX: 1,
            scaleY: 1,
            shear: 0,
            rotation: 0,
            angularVelocity: (Math.random() - 0.5) * 0.05,
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
            internalPoints: [],
            restShape: { width: width, height: height },
            
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ
            onGround: false,
            energy: 5, // –ù–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –±–æ–ª–µ–µ —ç–Ω–µ—Ä–≥–∏—á–Ω—ã–µ
            lastCollisionTime: Date.now(),
            isActive: true
        };

        this.createInternalStructure(obj);
        this.setupElement(obj.element);
        this.objects.push(obj);
        
        console.